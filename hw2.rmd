

```{r}
library(arrow)
library(dplyr)
library(tidyverse)
library(tsibble)
library(lubridate)
library(feasts)
library(fpp2)
library(tsibbledata)
theme_set(theme_minimal())

# read all green from the folder "visualization/data/parquet" parquet and union them
file_paths <- list.files("data/", pattern = "green_tripdata_2015-.*\\.parquet", full.names = TRUE)

# Initialize an empty list to store data
all_green_data <- list()

# Loop through the file paths and read each parquet file
for (file in file_paths) {
  all_green_data[[file]] <- arrow::read_parquet(file,
    as.data.frame = TRUE,
    col_select = c(
      "VendorID", "lpep_pickup_datetime",
      "lpep_dropoff_datetime", "passenger_count",
      "trip_distance",
      "total_amount"
    )
  )
}

# Combine all data into one data frame
combined_green_data <- do.call(rbind, all_green_data) |>
  mutate(
    lpep_pickup_datetime = as.POSIXct(lpep_pickup_datetime, origin = "1970-01-01", tz = "UTC"),
    lpep_dropoff_datetime = as.POSIXct(lpep_dropoff_datetime, origin = "1970-01-01", tz = "UTC")
  ) |>
  arrange(lpep_pickup_datetime)

print(head(combined_green_data), width = Inf)
```

```{r}
start <- as.Date("2015-01-01")
end <- as.Date("2015-01-31")
sample_size <- as.integer(nrow(combined_green_data) * (10^(-3)))
sample_size <- max(min(sample_size, nrow(combined_green_data)), 1) # Ensure sample_size is at least 1
sampled_data <- combined_green_data[sample(nrow(combined_green_data), sample_size), ] %>%
  arrange(lpep_pickup_datetime)
selected_date <- sampled_data %>%
  filter(
    lpep_pickup_datetime >= start,
    lpep_dropoff_datetime <= end,
    lpep_dropoff_datetime > lpep_pickup_datetime
  ) %>%
  mutate(trip_number = row_number())
data <- data %>%
  # Extract time of day as a continuous numeric variable for pickup and dropoff times
  mutate(
    pickup_time = as.numeric(format(lpep_pickup_datetime, "%H")) +
      as.numeric(format(lpep_pickup_datetime, "%M")) / 60,
    dropoff_time = as.numeric(format(lpep_dropoff_datetime, "%H")) +
      as.numeric(format(lpep_dropoff_datetime, "%M")) / 60
  ) %>%
  arrange(pickup_time) %>%
  mutate(trip_number = row_number())

ggplot(data) +
  # Segment plot showing trip number against pickup and dropoff times within a day
  geom_segment(aes(
    y = trip_number, x = pickup_time,
    xend = dropoff_time, yend = trip_number
  )) +
  # Histogram showing the number of trips per hour (binned by 1 hour)
  geom_histogram(aes(x = pickup_time),
    fill = "blue", alpha = 0.7, binwidth = 1
  ) + # Binwidth = 1 hour
  # Labels for the plot
  labs(y = "Trip Number", x = "Time of Day (hours)") +
  # Ensure the x-axis shows the full 24-hour range
  scale_x_continuous(breaks = seq(0, 24, by = 1), limits = c(0, 24)) +
  theme_minimal()
```

```{r}
print(tail(selected_date), width = Inf)
```

```{r}
library(shiny)
library(dplyr)
library(tsibble)
library(ggplot2)


# Define UI for the Shiny app
ui <- fluidPage(

  # Create slider for sample rate (log-10 scale, fraction between 0 and 1)
  sliderInput("sample_rate",
    label = "Sample Rate (Log-10 Scale):",
    min = -4, max = 0, value = -3, step = 1
  ), # Log-10 scale: from 0.0001 (10^-4) to 1 (10^0)

  titlePanel("NYC Green Taxi Trip Data Viewer"),

  # Date range selection for filtering
  dateRangeInput("date_range",
    label = "Select Date Range:",
    start = "2015-01-01",
    end = "2015-01-31", # Default date range
    min = if (nrow(combined_green_data) > 0) min(combined_green_data$lpep_pickup_datetime) else Sys.Date(),
    max = if (nrow(combined_green_data) > 0) max(combined_green_data$lpep_pickup_datetime) else Sys.Date(),
    format = "yyyy-mm-dd"
  ),

  # Display the two plots side by side
  fluidRow(
    column(6, plotOutput("seg_plot", brush = brushOpts(id = "plot_brush", direction = "x"))), # Segment plot
    column(6, plotOutput("distance_duration_plot")) # Distance vs Duration Plot
  ),
  titlePanel("NYC Green Taxi Trip Distance vs. Time of Day"),

  # Create checkbox inputs for months (default is January selected)
  fluidRow(
    column(3, checkboxGroupInput("selected_months1", label = NULL, choices = setNames(1:3, month.name[1:3]), selected = 1)),
    column(3, checkboxGroupInput("selected_months2", label = NULL, choices = setNames(4:6, month.name[4:6]), selected = NULL)),
    column(3, checkboxGroupInput("selected_months3", label = NULL, choices = setNames(7:9, month.name[7:9]), selected = NULL)),
    column(3, checkboxGroupInput("selected_months4", label = NULL, choices = setNames(10:12, month.name[10:12]), selected = NULL))
  ),
  # plotOutput("distance_time_plot"),
  # tableOutput("debug_table")
)

# Define server logic
server <- function(input, output, session) {
  # Sample the data based on the selected sample rate
  sampled_data <- reactive({
    sample_size <- as.integer(nrow(combined_green_data) * 10^input$sample_rate)
    sample_size <- max(min(sample_size, nrow(combined_green_data)), 1) # Ensure sample_size is at least 1
    combined_green_data[sample(nrow(combined_green_data), sample_size), ] %>%
      arrange(lpep_pickup_datetime)
  })

  # Reactive expression to filter data based on selected date range
  selected_date <- reactive({
    sampled_data() %>%
      filter(
        lpep_pickup_datetime >= as.POSIXct(input$date_range[1]) &
          lpep_dropoff_datetime <= as.POSIXct(input$date_range[2]),
        lpep_dropoff_datetime > lpep_pickup_datetime
      ) %>%
      mutate(
        pickup_time = as.numeric(format(lpep_pickup_datetime, "%H")) +
          as.numeric(format(lpep_pickup_datetime, "%M")) / 60,
        dropoff_time = as.numeric(format(lpep_dropoff_datetime, "%H")) +
          as.numeric(format(lpep_dropoff_datetime, "%M")) / 60,
        dropoff_time = ifelse(dropoff_time < pickup_time, dropoff_time + 24, dropoff_time)
      ) %>%
      arrange(pickup_time) %>%
      mutate(trip_number = row_number())
  })

  # Reactive expression to capture brushed points and compute distance vs. duration
  brushed_data <- reactive({
    brushed_points <- brushedPoints(selected_date(), input$plot_brush, xvar = "pickup_time", yvar = "trip_number")

    # Calculate the duration of each trip in minutes
    brushed_points %>%
      mutate(duration = as.numeric(difftime(lpep_dropoff_datetime, lpep_pickup_datetime, units = "mins")))
  })

  # Combine selected months from all checkbox groups
  selected_months <- reactive({
    c(input$selected_months1, input$selected_months2, input$selected_months3, input$selected_months4)
  })

  # Reactive expression to filter data based on selected months
  filtered_month_data <- reactive({
    sampled_data() %>%
      filter(month(lpep_pickup_datetime) %in% selected_months()) # Filter based on selected months
  })

  # Plotting the segment plot with swapped axes (trip_number on y-axis, time on x-axis)
  plot_seg <- function(data) {
    ggplot(data) +
      # Segment plot showing trip number against pickup and dropoff times within a day
      geom_segment(aes(
        y = trip_number, x = pickup_time,
        xend = dropoff_time, yend = trip_number
      )) +
      # Histogram showing the number of trips per hour (binned by 1 hour)
      geom_histogram(aes(x = pickup_time),
        fill = "blue", alpha = 0.7, binwidth = 1
      ) + # Binwidth = 1 hour
      # Labels for the plot
      labs(y = "Trip Number", x = "Time of Day (hours)") +
      # Ensure the x-axis shows the full 24-hour range
      scale_x_continuous(breaks = seq(0, 24, by = 1), limits = c(0, 24)) +
      theme_minimal()
  }


  # Scatter plot for distance vs. duration with color representing fare and size representing passenger count
  plot_distance_duration <- function(data) {
    ggplot(data, aes(x = duration, y = trip_distance, color = total_amount, size = passenger_count)) +
      geom_point(alpha = 0.7) +
      labs(
        x = "Trip Duration (minutes)", y = "Trip Distance (miles)",
        # color = "Fare Amount", size = "Passenger Count"
         size= "Fare Amount",  color = "Passenger Count"
      ) +
      theme_minimal()
  }

  plot_distance_time_scatter <- function(data) {
    # Extract time of day as a continuous numeric variable (hours + minutes as fraction)
    data <- data %>%
      mutate(time_of_day = as.numeric(format(lpep_pickup_datetime, "%H")) +
        as.numeric(format(lpep_pickup_datetime, "%M")) / 60)

    # Define the base plot with scatter points
    ggplot(data, aes(
      x = time_of_day, y = trip_distance,
      color = as.factor(month(lpep_pickup_datetime)),
      shape = as.factor(month(lpep_pickup_datetime))
    )) +
      # Scatter plot of trip distances
      geom_point(alpha = 0.7) +

      # Overlaid histogram for the time of day, binned by hour, semi-transparent
      geom_histogram(aes(x = time_of_day, y = ..count.., fill = as.factor(month(lpep_pickup_datetime))),
        binwidth = 1, alpha = 0.4, position = "identity", inherit.aes = FALSE
      ) +

      # Color scale for scatter plot and histogram (same colors)
      scale_color_manual(values = rainbow(12)) +
      scale_fill_manual(values = rainbow(12)) +

      # Labels and axis customization
      labs(
        x = "Time of Day (hours)", y = "Trip Distance (miles)",
        color = "Month", fill = "Month", shape = "Month",
        title = "Trip Distance vs. Time of Day with Histogram (Filtered by Month)"
      ) +
      scale_x_continuous(breaks = seq(0, 24, by = 1), limits = c(0, 24)) + # Ensure x-axis shows 24 hours
      theme_minimal()
  }

  # Render the segment plot
  output$seg_plot <- renderPlot({
    plot_seg(selected_date())
  })

  # Render the distance vs. duration plot with color representing fare and size representing passenger count
  output$distance_duration_plot <- renderPlot({
    data <- brushed_data()
    # If no points are brushed, use the full dataset
    if (nrow(data) == 0) {
      data <- selected_date() %>%
        mutate(duration = as.numeric(difftime(lpep_dropoff_datetime, lpep_pickup_datetime, units = "mins")))
    }
    plot_distance_duration(data)
  })

  # output$debug_table <- renderTable({
  #   brushed_data()
  # })

  # Plotting Trip Distance vs Time of Day with different colors and shapes for each month
  # output$distance_time_plot <- renderPlot({
  #   data <- filtered_month_data()

  #   # Check if there's data to plot
  #   if (nrow(data) == 0) {
  #     return(NULL)
  #   }

  #   plot_distance_time_scatter(data)
  # })
}

# Run the application
shinyApp(ui = ui, server = server)
```

```{r}
# read one month data
file_path <- "data/green_tripdata_2015-01.parquet"
data <- arrow::read_parquet(file_path, as.data.frame = TRUE)
```